package conn

import (
	"ApricusFakemysql/core/proto"
	"ApricusFakemysql/core/utils"
	"fmt"
	"io/ioutil"
	"log"
	"net"
)

var shouldDisplayFileContentOnScreen bool = true
var shouldSaveToFile bool = true

// fileOutputDir  todo 用户输入指定路径
var fileOutputDir string = "../../output"

func NewMysqlPacketBigFileReader(clientSocket net.Conn) *MysqlPacketReader {
	seq := CreateMysqlStreamSequence()
	reader := CreateMysqlPacketReader(clientSocket, seq)
	return reader
}

// MysqlFileRead todo  多种加密方式
func MysqlFileRead(Username string, clientSocket net.Conn) {
	IfRead, Filename := utils.CheckAndRemove(Username, "readFile=")
	if IfRead {
		log.Print("Start Reading File:" + Filename)
		// 发送文件读取请求数据包
		fileReadPacket := proto.NewPacket(1, append([]byte{0xfb}, []byte(Filename)...))
		clientSocket.Write(fileReadPacket)
		var isEnd = false

		var outContent []byte
		PacketReader := NewMysqlPacketBigFileReader(clientSocket)
		for !isEnd {
			// 读取数据包
			fileData, _ := PacketReader.Read()

			// 当前packet没有未读取完的数据
			if len(fileData) == 0 {
				break
			}
			// 空包, 文件读取结束
			if len(fileData) == 1 && fileData[0] == 0x00 {
				isEnd = true
				break
			}

			outContent = append(outContent, fileData...)
		}
		if len(outContent) == 0 {
			fmt.Println("Nothing had been read")
		} else {
			if shouldDisplayFileContentOnScreen {
				fmt.Println("========File Content Preview=========")
				contentLength := len(outContent)
				if contentLength > 1000 {
					contentLength = 1000
				}
				fmt.Println(string(outContent[:contentLength]))
				fmt.Println("=======File Content Preview End==========")
			}

			if shouldSaveToFile {
				outputFileName := fmt.Sprintf("%s/%s", fileOutputDir, utils.ExtractFileName(Filename))
				err := ioutil.WriteFile(outputFileName, outContent, 0644)
				if err == nil {
					fmt.Println("Save to File:", outputFileName)
				} else {
					fmt.Println("Failed to save file:", err)
				}
			}
		}
	}
}
